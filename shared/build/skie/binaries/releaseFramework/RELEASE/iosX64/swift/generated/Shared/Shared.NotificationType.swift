// Generated by Touchlab SKIE 0.10.1

import Foundation

@frozen
public enum NotificationType : Swift.Hashable, Swift.CaseIterable, Swift._ObjectiveCBridgeable {

    case morningRecovery
    case bedtimeReminder
    case strainTarget
    case weeklyReport
    case healthAlert
    case journalReminder
    case coachInsight

    public var description_: Swift.String {
        return (self as _ObjectiveCType).description_
    }

    public var label: Swift.String {
        return (self as _ObjectiveCType).label
    }

    public var name: Swift.String {
        return (self as _ObjectiveCType).name
    }

    public var ordinal: Swift.Int32 {
        return (self as _ObjectiveCType).ordinal
    }

    public static func _forceBridgeFromObjectiveC(_ source: ApexFitShared.__NotificationType, result: inout ApexFitShared.NotificationType?) -> Swift.Void {
        result = fromObjectiveC(source)
    }

    public static func _conditionallyBridgeFromObjectiveC(_ source: ApexFitShared.__NotificationType, result: inout ApexFitShared.NotificationType?) -> Swift.Bool {
        result = fromObjectiveC(source)
        return true
    }

    public static func _unconditionallyBridgeFromObjectiveC(_ source: ApexFitShared.__NotificationType?) -> Self {
        return fromObjectiveC(source)
    }

    public func _bridgeToObjectiveC() -> ApexFitShared.__NotificationType {
        switch self {
        case .morningRecovery: return ApexFitShared.__NotificationType.morningRecovery as ApexFitShared.__NotificationType
        case .bedtimeReminder: return ApexFitShared.__NotificationType.bedtimeReminder as ApexFitShared.__NotificationType
        case .strainTarget: return ApexFitShared.__NotificationType.strainTarget as ApexFitShared.__NotificationType
        case .weeklyReport: return ApexFitShared.__NotificationType.weeklyReport as ApexFitShared.__NotificationType
        case .healthAlert: return ApexFitShared.__NotificationType.healthAlert as ApexFitShared.__NotificationType
        case .journalReminder: return ApexFitShared.__NotificationType.journalReminder as ApexFitShared.__NotificationType
        case .coachInsight: return ApexFitShared.__NotificationType.coachInsight as ApexFitShared.__NotificationType
        }
    }

    private static func fromObjectiveC(_ source: ApexFitShared.__NotificationType?) -> Self {
        guard let source = source else {
            fatalError("Couldn't map value of \(Swift.String(describing: source)) to ApexFitShared.NotificationType")
        }
        if source == ApexFitShared.__NotificationType.morningRecovery as ApexFitShared.__NotificationType {
            return .morningRecovery
        } else if source == ApexFitShared.__NotificationType.bedtimeReminder as ApexFitShared.__NotificationType {
            return .bedtimeReminder
        } else if source == ApexFitShared.__NotificationType.strainTarget as ApexFitShared.__NotificationType {
            return .strainTarget
        } else if source == ApexFitShared.__NotificationType.weeklyReport as ApexFitShared.__NotificationType {
            return .weeklyReport
        } else if source == ApexFitShared.__NotificationType.healthAlert as ApexFitShared.__NotificationType {
            return .healthAlert
        } else if source == ApexFitShared.__NotificationType.journalReminder as ApexFitShared.__NotificationType {
            return .journalReminder
        } else if source == ApexFitShared.__NotificationType.coachInsight as ApexFitShared.__NotificationType {
            return .coachInsight
        } else {
            fatalError("Couldn't map value of \(Swift.String(describing: source)) to ApexFitShared.__NotificationType")
        }
    }

    public typealias _ObjectiveCType = ApexFitShared.__NotificationType

}

extension ApexFitShared.NotificationType {

    public func toKotlinEnum() -> ApexFitShared.__NotificationType {
        return _bridgeToObjectiveC()
    }

}

extension ApexFitShared.__NotificationType {

    public func toSwiftEnum() -> ApexFitShared.NotificationType {
        return ApexFitShared.NotificationType._unconditionallyBridgeFromObjectiveC(self)
    }

}
